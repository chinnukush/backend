import os
from pyrogram import Client, filters
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message
from pyrogram.errors import ChatAdminRequired, UserNotParticipant
from pyrogram.handlers import ChatMemberUpdatedHandler

CHANNEL = int(os.getenv("CHANNEL", "-1002440757122"))  # replace with your channel ID

# Temporary store for pending requests
pending_requests = {}

async def is_req_subscribed(client: Client, message: Message) -> bool:
    """Check if user is subscribed to CHANNEL."""
    try:
        member = await client.get_chat_member(CHANNEL, message.from_user.id)
        return member.status in ("member", "administrator", "creator")
    except UserNotParticipant:
        return False
    except Exception as e:
        LOGGER.error(f"Error checking subscription: {e}")
        return False


@StreamBot.on_message(filters.command('start') & filters.private)
async def start(bot: Client, message: Message):
    LOGGER.info(f"Received command: {message.text}")

    command_part = message.text.split('start ')[-1]

    if command_part.startswith("file_"):
        usr_cmd = command_part[len("file_"):].strip()

        # ğŸ”’ Force Subscribe check
        if CHANNEL and not await is_req_subscribed(bot, message):
            # Save request for later
            pending_requests[message.from_user.id] = usr_cmd
            try:
                invite_link = await bot.create_chat_invite_link(
                    int(CHANNEL), creates_join_request=True
                )
            except ChatAdminRequired:
                LOGGER.error("Make sure Bot is admin in ForceSub channel")
                return

            btn = [[
                InlineKeyboardButton(
                    "ğŸ“Œ á´Šá´ÉªÉ´ á´œá´˜á´…á´€á´›á´‡êœ± á´„Êœá´€É´É´á´‡ÊŸ ğŸ“Œ", url=invite_link.invite_link
                )
            ]]
            await message.reply_text(
                "âš ï¸ You must join our updates channel to access files.\n\n"
                "After joining, the bot will automatically send your file.",
                reply_markup=InlineKeyboardMarkup(btn)
            )
            return

        # âœ… Continue with your existing file logic
        await send_file(bot, message, usr_cmd)

    else:
        # Plain /start â†’ welcome message
        await message.reply_text(
            "Éª á´€á´ Êœá´‡Ê€á´‡ á´›á´ á´˜Ê€á´á´ Éªá´…á´‡ á´…ÉªÊ€á´‡á´„á´› á´…á´á´¡É´ÊŸá´á´€á´… ÊŸÉªÉ´á´‹êœ± Ò“á´Ê€ á´á´á´ Éªá´‡êœ± & êœ±á´‡Ê€Éªá´‡êœ± Ò“Ê€á´á´ https://hk-movies.vercel.app ğŸ“¥ á´Šá´œêœ±á´› êœ±á´‡É´á´… á´€ Ò“ÉªÊŸá´‡ ÊŸÉªÉ´á´‹ á´›á´ É¢á´‡á´› êœ±á´›á´€Ê€á´›á´‡á´…!"
        )


async def send_file(bot: Client, message: Message, usr_cmd: str):
    """Your existing file sending logic extracted into a helper."""
    parts = usr_cmd.split("_")

    try:
        if len(parts) == 2:
            tmdb_id, quality = parts
            tmdb_id = int(tmdb_id)
            quality_details = await db.get_quality_details(tmdb_id, quality)

        elif len(parts) == 3:
            tmdb_id, season, quality = parts
            tmdb_id = int(tmdb_id)
            season = int(season)
            quality_details = await db.get_quality_details(tmdb_id, quality, season)

        elif len(parts) == 4:
            tmdb_id, season, episode, quality = parts
            tmdb_id = int(tmdb_id)
            season = int(season)
            episode = int(episode)
            quality_details = await db.get_quality_details(tmdb_id, quality, season, episode)

        else:
            await message.reply_text("Invalid command format.")
            return
    except ValueError:
        await message.reply_text("Invalid command format.")
        return

    sent_messages = []
    for detail in quality_details:
        decoded_data = await decode_string(detail['id'])
        channel = f"-100{decoded_data['chat_id']}"
        msg_id = decoded_data['msg_id']
        name = detail['name']
        if "\\n" in name and name.endswith(".mkv"):
            name = name.rsplit(".mkv", 1)[0].replace("\\n", "\n")
        try:
            file = await bot.get_messages(int(channel), int(msg_id))
            media = file.document or file.video
            if media:
                sent_msg = await message.reply_cached_media(
                    file_id=media.file_id,
                    caption=f'{name}'
                )
                sent_messages.append(sent_msg)
                await asleep(1)
        except FloodWait as e:
            LOGGER.info(f"Sleeping for {e.value}s")
            await asleep(e.value)
            await message.reply_text(f"Got Floodwait of {e.value}s")
        except Exception as e:
            LOGGER.error(f"Error retrieving/sending media: {e}")
            await message.reply_text("Error retrieving media.")

    if sent_messages:
        warning_msg = await message.reply_text(
            "Forward these files to your saved messages. These files will be deleted from the bot within 5 minutes."
        )
        sent_messages.append(warning_msg)
        create_task(delete_messages_after_delay(sent_messages))


# ğŸ”” Listen for channel join events
@StreamBot.on_chat_member_updated()
async def member_update(bot: Client, event):
    if event.chat.id == CHANNEL and event.new_chat_member.user.id in pending_requests:
        usr_cmd = pending_requests.pop(event.new_chat_member.user.id)
        # Send file automatically after join
        dummy_msg = Message(
            id=0, chat=event.new_chat_member.user, from_user=event.new_chat_member.user
        )
        await send_file(bot, dummy_msg, usr_cmd)
